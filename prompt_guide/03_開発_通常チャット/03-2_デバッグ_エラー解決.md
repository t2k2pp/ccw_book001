# 第3章: 開発・エンジニアリング（通常チャット）

## 3-2. デバッグ・エラー解決

このセクションでは、バグの特定やエラー解決に役立つプロンプトを紹介します。

---

### 🐛 バグの原因特定

#### 使用手法
- **Chain-of-Thought**（段階的な原因究明）
- **Self-Consistency**（複数の仮説を検証）

#### 期待する効果
- バグの根本原因を正確に特定
- 複数の可能性を体系的に検討
- 効率的なデバッグプロセス

#### 推奨モデル
- **推奨**: Claude 3.5 Sonnet, GPT-4o, o1（複雑なバグ分析時）
- **理由**: 論理的な推論とデバッグに優れる

#### プロンプト例

```
あなたは経験豊富なデバッグエンジニアです。
以下のバグについて、原因を段階的に特定してください。

【バグ情報】
- 症状: [具体的にどんな問題が起きているか]
- 期待する動作: [本来どうあるべきか]
- 実際の動作: [実際にはどうなっているか]
- 再現手順:
  1. [手順1]
  2. [手順2]
  3. [手順3]
- 再現性: [必ず発生 / 時々発生 / 特定条件で発生]

【関連コード】
\`\`\`[言語]
[バグが発生していると思われるコード]
\`\`\`

【環境情報】
- OS: [OS名とバージョン]
- 言語/フレームワーク: [環境]
- 依存ライブラリ: [関連するライブラリ]

【デバッグステップ】
ステップ1: 症状の整理と現象の分類
ステップ2: 仮説の立案（複数）
ステップ3: 各仮説の検証方法の提案
ステップ4: 最も可能性の高い原因の特定
ステップ5: 検証手順の提示

【出力形式】
## バグ分析レポート

### 1. 症状の整理

**現象**: [何が起きているか]

**影響範囲**: [どこに影響しているか]

**重大度**: [高/中/低]

### 2. 仮説の立案

#### 仮説1: [仮説のタイトル]
- **内容**: [どのような原因が考えられるか]
- **可能性**: [高/中/低]
- **根拠**: [なぜこの仮説を立てたか]
- **検証方法**: [この仮説を確かめるには]

#### 仮説2: [仮説のタイトル]
[同上]

#### 仮説3: [仮説のタイトル]
[同上]

### 3. コード分析

#### 疑わしい箇所1: [ファイル名:行番号]
\`\`\`[言語]
[該当コード]
\`\`\`

**問題の可能性**: [何が問題か]
**確認ポイント**: [何を確認すべきか]

#### 疑わしい箇所2: [ファイル名:行番号]
[同上]

### 4. 最も可能性の高い原因

🎯 **[仮説番号]: [原因]**

**理由**:
1. [根拠1]
2. [根拠2]
3. [根拠3]

**該当コード**:
\`\`\`[言語]
// この部分が原因と考えられる
[該当コード]
\`\`\`

**問題の詳細**:
[具体的に何が問題なのか]

### 5. 検証手順

#### ステップ1: [検証内容]
\`\`\`[言語]
// デバッグコードの追加例
[検証用のコード]
\`\`\`

**期待される結果**: [もし原因が正しければこうなる]

#### ステップ2: [検証内容]
[同上]

### 6. 仮修正案

\`\`\`[言語]
// 修正案（検証前）
[修正したコード]
\`\`\`

**変更点**:
- [変更1]
- [変更2]

**なぜこの修正で解決するか**:
[説明]

### 7. 追加で確認すべきこと
- [ ] [確認事項1]
- [ ] [確認事項2]
- [ ] [確認事項3]

### 8. 類似バグの可能性
⚠️ 同様のパターンで他にもバグがある可能性：
- [箇所1]
- [箇所2]

上記の形式で、体系的なバグ分析を提供してください。
```

---

### 💥 パフォーマンス問題の診断

#### 使用手法
- **Chain-of-Thought**（ボトルネック特定プロセス）
- **Role Prompting**（パフォーマンスエンジニアの役割）

#### 期待する効果
- パフォーマンスボトルネックの特定
- 具体的な最適化提案
- 計測可能な改善目標の設定

#### 推奨モデル
- **推奨**: GPT-4o, Claude 3.5 Sonnet, o1（複雑な最適化戦略時）
- **理由**: パフォーマンス分析と最適化提案に優れる

#### プロンプト例

```
あなたはパフォーマンスエンジニアリングの専門家です。
以下のパフォーマンス問題を診断し、最適化案を提案してください。

【問題の概要】
- 症状: [動作が遅い、メモリ消費が多い等]
- 問題箇所: [どの機能・処理で発生するか]
- 測定値:
  - 現在の処理時間: [X秒]
  - 目標処理時間: [Y秒]
  - メモリ使用量: [Z MB]

【対象コード】
\`\`\`[言語]
[パフォーマンス問題が発生しているコード]
\`\`\`

【プロファイリング情報（あれば）】
[パフォーマンス計測結果]

【制約条件】
- [大規模なリファクタリングは不可等の制約]

【出力形式】
## パフォーマンス診断レポート

### 1. 問題の概要
- **症状**: [何が遅いか]
- **影響**: [ユーザー体験への影響]
- **優先度**: [高/中/低]

### 2. ボトルネック分析

#### ボトルネック1: [箇所]
\`\`\`[言語]
// 問題のあるコード
[該当コード]
\`\`\`

- **問題**: [何が遅くしているか]
- **計算量**: [現在のオーダー]
- **影響度**: [全体に占める割合]

#### ボトルネック2: [箇所]
[同上]

### 3. 最適化提案（優先度順）

#### 最適化1: [タイトル]（優先度: 高）

**現状の問題点**:
[具体的な問題]

**最適化案**:
\`\`\`[言語]
// 最適化後のコード
[改善したコード]
\`\`\`

**改善内容**:
- [変更点1]
- [変更点2]

**期待される効果**:
- 処理時間: [X秒] → [Y秒] ([Z%]改善)
- メモリ使用量: [A MB] → [B MB] ([C%]削減)

**実装難易度**: [低/中/高]

**トレードオフ**:
- [考慮すべきトレードオフ]

---

#### 最適化2: [タイトル]（優先度: 中）
[同上]

---

#### 最適化3: [タイトル]（優先度: 低）
[同上]

### 4. 最適化効果の試算

| 最適化 | 処理時間改善 | メモリ削減 | 実装コスト | ROI |
|--------|--------------|------------|------------|-----|
| 最適化1 | -60% | -20% | 低 | ⭐⭐⭐ |
| 最適化2 | -30% | -50% | 中 | ⭐⭐ |
| 最適化3 | -10% | -10% | 高 | ⭐ |

**推奨実施順序**: 最適化1 → 最適化2 → 最適化3

### 5. 実装ロードマップ

#### フェーズ1（即実施）
- [ ] [最適化1の実装]
- [ ] [パフォーマンステスト]
- [ ] [効果測定]

#### フェーズ2（短期）
- [ ] [最適化2の実装]
- [ ] [効果測定]

#### フェーズ3（中長期）
- [ ] [最適化3の検討]

### 6. 計測・モニタリング方法

\`\`\`[言語]
// パフォーマンス計測コード
[計測用のコード]
\`\`\`

**計測すべき指標**:
- [指標1]
- [指標2]
- [指標3]

### 7. ベストプラクティス
今後のパフォーマンス問題を防ぐために：
- 💡 [ベストプラクティス1]
- 💡 [ベストプラクティス2]
- 💡 [ベストプラクティス3]

上記の形式で、実用的なパフォーマンス診断を提供してください。
```

---

### 🔍 メモリリーク・リソース問題の診断

#### 使用手法
- **Chain-of-Thought**（段階的な原因追跡）
- **Role Prompting**（システムエンジニアの視点）

#### 期待する効果
- メモリリークやリソースリークの原因特定
- 適切なリソース管理の実装
- 再発防止策の提案

#### 推奨モデル
- **推奨**: Claude 3.5 Sonnet, GPT-4o
- **理由**: システムレベルの問題分析に優れる

#### プロンプト例

```
あなたはシステムエンジニアリングの専門家です。
以下のメモリリーク/リソース問題を診断してください。

【問題の詳細】
- 症状: [メモリ使用量が増加し続ける、ファイルハンドルが解放されない等]
- 発生タイミング: [どのような操作後に発生するか]
- 環境: [OS、言語、フレームワーク]

【関連コード】
\`\`\`[言語]
[問題が発生していると思われるコード]
\`\`\`

【プロファイリング情報】
[メモリプロファイラの結果等]

【出力形式】
## リソースリーク診断レポート

### 1. 症状の分析
- **問題のタイプ**: [メモリリーク / ファイルリーク / コネクションリーク]
- **リーク速度**: [X MB/時間]
- **影響**: [システムへの影響]

### 2. 原因の特定

#### 疑わしい箇所1: [箇所の説明]
\`\`\`[言語]
// 問題のあるコード
[該当コード]
\`\`\`

**問題点**:
❌ [何が問題か]

**なぜリークするか**:
[リークのメカニズム]

#### 疑わしい箇所2: [箇所の説明]
[同上]

### 3. 修正案

#### 修正1: [修正のタイトル]
\`\`\`[言語]
// 修正後のコード
[修正したコード]
\`\`\`

**変更点**:
- [変更内容1]
- [変更内容2]

**なぜこれで解決するか**:
[説明]

#### 修正2: [修正のタイトル]
[同上]

### 4. リソース管理のベストプラクティス

\`\`\`[言語]
// 適切なリソース管理の例
[ベストプラクティスのコード]
\`\`\`

**ポイント**:
- ✅ [ポイント1]
- ✅ [ポイント2]
- ✅ [ポイント3]

### 5. 検証方法

\`\`\`[言語]
// リークが修正されたことを確認するコード
[検証用のコード]
\`\`\`

**確認手順**:
1. [手順1]
2. [手順2]
3. [手順3]

**期待される結果**:
[修正が成功していればこうなる]

### 6. 再発防止策
- [ ] [防止策1]
- [ ] [防止策2]
- [ ] [防止策3]

### 7. モニタリング

\`\`\`[言語]
// リソース使用量のモニタリングコード
[モニタリングコード]
\`\`\`

上記の形式で、実用的な診断レポートを提供してください。
```

---

### 🧪 テストが失敗する原因の特定

#### 使用手法
- **Chain-of-Thought**（テスト失敗の分析プロセス）
- **Self-Consistency**（複数の原因を検証）

#### 期待する効果
- テスト失敗の根本原因を特定
- テストコードと実装コードの問題を区別
- 適切な修正方針の提示

#### 推奨モデル
- **推奨**: Claude 3.5 Sonnet, GPT-4o
- **理由**: テストコード分析に優れる

#### プロンプト例

```
以下の失敗しているテストについて、原因を分析してください。

【テスト情報】
- テストフレームワーク: [Jest / PyTest / JUnit等]
- 失敗しているテスト: [テスト名]
- エラーメッセージ:
\`\`\`
[エラーメッセージ]
\`\`\`

【テストコード】
\`\`\`[言語]
[テストコード]
\`\`\`

【テスト対象のコード】
\`\`\`[言語]
[実装コード]
\`\`\`

【出力形式】
## テスト失敗分析

### 1. エラーの概要
- **失敗の種類**: [アサーションエラー / 例外 / タイムアウト]
- **期待値**: [テストが期待していること]
- **実際の値**: [実際に何が返されたか]

### 2. 原因の分析

#### 可能性1: 実装コードの問題
**該当箇所**:
\`\`\`[言語]
[問題のあるコード]
\`\`\`

**問題点**: [何が間違っているか]

#### 可能性2: テストコードの問題
**該当箇所**:
\`\`\`[言語]
[問題のあるテストコード]
\`\`\`

**問題点**: [テストの期待値が間違っている等]

#### 可能性3: テスト環境の問題
**問題点**: [環境依存の問題等]

### 3. 最も可能性の高い原因
🎯 [原因の特定]

**根拠**:
[なぜこれが原因と考えられるか]

### 4. 修正案

#### 実装コードの修正
\`\`\`[言語]
// 修正後のコード
[修正したコード]
\`\`\`

#### テストコードの修正（必要な場合）
\`\`\`[言語]
// 修正後のテストコード
[修正したテストコード]
\`\`\`

### 5. 追加すべきテストケース
\`\`\`[言語]
// エッジケースのテスト
[追加のテストコード]
\`\`\`

上記の形式で、テスト失敗の分析を提供してください。
```

---

### 🔧 レガシーコードのリファクタリング支援

#### 使用手法
- **Chain-of-Thought**（段階的なリファクタリング計画）
- **Constraint Prompting**（既存機能を壊さない制約）

#### 期待する効果
- 安全なリファクタリング手順の提示
- リスクの最小化
- テストカバレッジの向上

#### 推奨モデル
- **推奨**: Claude 3.5 Sonnet, GPT-4o, o1（複雑なリファクタリング戦略時）
- **理由**: 段階的な変更計画の立案に優れる

#### プロンプト例

```
以下のレガシーコードを安全にリファクタリングする計画を立ててください。

【対象コード】
\`\`\`[言語]
[リファクタリング対象のコード]
\`\`\`

【現状の問題点】
- [問題1]
- [問題2]
- [問題3]

【制約条件】
- 既存機能を壊さない
- [その他の制約]

【出力形式】
## リファクタリング計画

### 1. 現状分析

**コードの問題点**:
- ❌ [問題1の詳細]
- ❌ [問題2の詳細]
- ❌ [問題3の詳細]

**リスク評価**: [高/中/低]

### 2. リファクタリング戦略

#### ステップ1: テストの追加
\`\`\`[言語]
// まず現在の動作を保証するテストを追加
[テストコード]
\`\`\`

#### ステップ2: [小さな改善1]
**変更内容**: [何を変えるか]

**変更前**:
\`\`\`[言語]
[変更前のコード]
\`\`\`

**変更後**:
\`\`\`[言語]
[変更後のコード]
\`\`\`

**リスク**: [低/中/高]
**検証方法**: [テストの実行等]

#### ステップ3: [小さな改善2]
[同上]

#### ステップ4: [大きな構造変更]
[同上]

### 3. 最終形

\`\`\`[言語]
// リファクタリング完了後のコード
[最終的なコード]
\`\`\`

**改善点**:
- ✅ [改善1]
- ✅ [改善2]
- ✅ [改善3]

### 4. ロールバック計画
万が一問題が発生した場合：
- [ロールバック手順]

上記の形式で、安全なリファクタリング計画を提供してください。
```

---

## まとめ

このセクションでは、以下のデバッグ・エラー解決タスクに対応するプロンプトを紹介しました：

| タスク | 主要手法 | 推奨モデル |
|--------|----------|------------|
| バグ原因特定 | CoT + Self-Consistency | Claude 3.5 Sonnet, GPT-4o, o1 |
| パフォーマンス診断 | CoT + Role | GPT-4o, Claude 3.5 Sonnet, o1 |
| メモリリーク診断 | CoT + Role | Claude 3.5 Sonnet, GPT-4o |
| テスト失敗分析 | CoT + Self-Consistency | Claude 3.5 Sonnet, GPT-4o |
| リファクタリング支援 | CoT + Constraint | Claude 3.5 Sonnet, GPT-4o, o1 |

次のセクションでは、設計・アーキテクチャ相談に関するプロンプトを紹介します。
