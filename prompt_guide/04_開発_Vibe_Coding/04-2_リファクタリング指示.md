# 第4章: 開発・エンジニアリング（Vibe Coding）

## 4-2. リファクタリング指示

このセクションでは、AI駆動開発ツールでのリファクタリング指示について解説します。

---

### ⚠️ リファクタリング時の重要な注意点

リファクタリングをAIに依頼する際は、以下の点を**必ず明示**してください：

```
このファイルをリファクタリングしてください。

【重要な制約】
- 既存の機能を100%保持すること
- 機能の追加・削除は一切行わないこと
- 外部から見た動作は完全に同じであること
```

**なぜ重要か**：
AIは「良かれと思って」機能を追加・変更・削除することがあります。
これは**リファクタリングではなく、仕様変更**です。必ず制約を明示しましょう。

---

### 🔄 コードの構造改善

#### 使用手法
- **Constraint Prompting**（機能保持の制約）
- **Role Prompting**（リファクタリング専門家の役割）

#### 期待する効果
- 可読性の向上
- 保守性の向上
- パフォーマンスの改善（必要な場合）

#### プロンプト例

```
以下のファイルをリファクタリングしてください。

【対象ファイル】
[ファイルパス]

【リファクタリングの目的】
[可読性向上 / パフォーマンス改善 / テスタビリティ向上]

【絶対に守るべき制約】
- 既存の機能・動作を100%保持
- 外部からのインターフェース（関数シグネチャ、export等）は変更しない
- 既存のテストが全て通ること

【改善してほしい点】
- [長すぎる関数の分割]
- [重複コードの削除]
- [変数名の改善]
- [コメントの追加・改善]

【改善してほしくない点】
- 新しい機能の追加
- 既存機能の削除
- ロジックの変更（パフォーマンス改善を除く）

リファクタリング前後で動作が完全に同じことを確認してください。
```

**具体例：肥大化した関数の分割**

```
src/services/OrderService.ts の `processOrder` 関数をリファクタリングしてください。

【問題点】
- 300行を超える巨大な関数
- 複数の責任を持っている（バリデーション、計算、DB操作、通知）
- テストが困難

【リファクタリング方針】
- 単一責任の原則に従って関数を分割
- 各関数は50行以内を目安に
- わかりやすい関数名を付ける

【絶対に守るべき制約】
- `processOrder` の引数と戻り値は変更しない
- 既存の動作を100%保持
- 既存のテスト（tests/services/OrderService.test.ts）が全て通ること

【期待する構造】
\`\`\`typescript
// メイン関数
export async function processOrder(orderId: string): Promise<OrderResult> {
  // ここは高レベルの流れのみ
  const order = await validateOrder(orderId);
  const calculations = calculateOrderTotals(order);
  const result = await saveOrderToDatabase(order, calculations);
  await sendNotifications(result);
  return result;
}

// 分割された関数群（privateまたは別ファイル）
async function validateOrder(orderId: string): Promise<Order> { ... }
function calculateOrderTotals(order: Order): OrderCalculations { ... }
async function saveOrderToDatabase(...): Promise<OrderResult> { ... }
async function sendNotifications(result: OrderResult): Promise<void> { ... }
\`\`\`

リファクタリング後、既存テストを実行して全て通ることを確認してください。
```

---

### 📦 ファイル分割・モジュール化

#### 使用手法
- **Constraint Prompting**（機能保持 + インポート/エクスポートの整合性）

#### 期待する効果
- 適切な責任分離
- 再利用性の向上
- ファイルサイズの適正化

#### プロンプト例

```
[ファイルパス] を複数のファイルに分割してください。

【現状の問題】
- 1000行を超える巨大ファイル
- 複数の責任が混在
- [具体的な問題点]

【分割方針】
- [クラス/関数/コンポーネント]ごとに個別ファイルに
- 共通的なものは [ディレクトリ]/shared/ に配置
- 型定義は [ディレクトリ]/types/ に配置

【絶対に守るべき制約】
- 既存の機能を100%保持
- 他のファイルからのimportパスが壊れないよう、必要に応じてindex.tsを作成
- 既存のテストが全て通ること

【期待するファイル構成】
\`\`\`
[ディレクトリ]/
├── ComponentA.tsx
├── ComponentB.tsx
├── shared/
│   └── utils.ts
├── types/
│   └── index.ts
└── index.ts (re-export用)
\`\`\`

分割後、全てのimportが正しく解決され、ビルドが成功することを確認してください。
```

---

### ⚡ パフォーマンス最適化

#### 使用手法
- **Chain-of-Thought**（最適化の根拠を示す）
- **Constraint Prompting**（機能保持の制約）

#### 期待する効果
- 処理速度の向上
- メモリ使用量の削減
- スケーラビリティの向上

#### プロンプト例

```
[ファイルパス] のパフォーマンスを最適化してください。

【現状の問題】
- 処理時間: [X秒]
- 目標: [Y秒以内]
- ボトルネック: [具体的な箇所]

【最適化の観点】
- アルゴリズムの改善（計算量の削減）
- 不要な計算の削除
- キャッシュの活用
- 非同期処理の最適化

【絶対に守るべき制約】
- 既存の機能・動作を100%保持
- 出力結果は完全に同じであること
- 既存のテストが全て通ること

【最適化前後の計測】
最適化前の処理時間を計測し、最適化後と比較してください。
改善率（%）も示してください。

それでは最適化をお願いします。
```

---

### 🧹 コード品質の向上

#### 使用手法
- **Constraint Prompting**（Linterルール、コーディング規約）

#### 期待する効果
- Lintエラーの解消
- コーディング規約への準拠
- 型安全性の向上

#### プロンプト例

```
[ファイルパス] のコード品質を向上させてください。

【改善観点】
- ESLint/TSLintエラーの修正
- [プロジェクトのコーディング規約] への準拠
- 型の any を適切な型に置き換え
- 使用していないimportの削除
- マジックナンバーを定数化

【絶対に守るべき制約】
- 既存の機能・動作を100%保持
- 既存のテストが全て通ること

それでは改善をお願いします。
```

---

### 🧪 テスタビリティの向上

#### 使用手法
- **Role Prompting**（テスト専門家の視点）

#### 期待する効果
- テストしやすい構造への変更
- 依存性の注入
- モック可能な設計

#### プロンプト例

```
[ファイルパス] をテストしやすい構造にリファクタリングしてください。

【現状の問題】
- 外部依存が多くモックが困難
- 副作用が多い
- テストカバレッジ: [X%]

【改善方針】
- 依存性の注入（DI）を導入
- 純粋関数化できる部分は純粋関数に
- 副作用を分離

【絶対に守るべき制約】
- 既存の機能・動作を100%保持
- 既存のテストが全て通ること

【期待する結果】
- テストカバレッジ: [Y%]以上
- 新しいテストコードも一緒に追加

それでは実装をお願いします。
```

---

### 🔒 型安全性の向上（TypeScript）

#### 使用手法
- **Constraint Prompting**（strictモードへの準拠）

#### 期待する効果
- コンパイルエラーの削減
- 実行時エラーの防止
- IDEの補完機能向上

#### プロンプト例

```
[ファイルパス] の型安全性を向上させてください。

【改善観点】
- `any` を適切な型に置き換え
- `as` によるキャストを最小限に
- Union型やGenericsを適切に使用
- strictモードでエラーが出ないように

【絶対に守るべき制約】
- 既存の機能・動作を100%保持
- 既存のテストが全て通ること

それでは改善をお願いします。
```

---

## リファクタリングの実践Tips

### ✅ 安全なリファクタリングの進め方

```
# ステップ1: テストの確認
既存のテストが全て通ることを確認してください。

# ステップ2: リファクタリング依頼
[具体的なリファクタリング指示]

【重要な制約】
- 既存機能を100%保持
- 既存のテストが全て通ること

# ステップ3: テストの実行確認
リファクタリング後、全てのテストを実行してください。
結果を教えてください。

# ステップ4: 動作確認
実際に[機能]を動かして、正しく動作することを確認してください。
```

### ❌ やってはいけないリファクタリング指示

```
# 悪い例1：制約が不明確
このファイルをリファクタリングして。
```
→ AIが勝手に機能追加・削除する可能性

```
# 悪い例2：リファクタリングと機能追加を同時に
このファイルをリファクタリングして、ついでにXX機能も追加して。
```
→ リファクタリングと機能追加は分けて行うべき

```
# 悪い例3：テスト確認を省略
リファクタリングして。（テストの実行確認を依頼しない）
```
→ 壊れていても気づかない

### 段階的リファクタリングの例

```
# フェーズ1: 変数名・関数名の改善
まず、変数名と関数名をわかりやすく改善してください。
ロジックは一切変更しないこと。

# フェーズ2: 関数の分割
次に、長い関数を小さな関数に分割してください。
各関数は単一の責任を持つように。

# フェーズ3: ファイル分割
最後に、複数のファイルに分割してください。
適切なディレクトリ構成も提案してください。

各フェーズの後にテストを実行し、全て通ることを確認してください。
```

---

## まとめ

Vibe Codingでのリファクタリングでは、以下を必ず守りましょう：

| ルール | 説明 |
|--------|------|
| **機能保持を明示** | 「既存機能を100%保持」を必ず指示 |
| **テスト実行確認** | リファクタリング後に必ずテスト実行 |
| **段階的に進める** | 一度に大規模な変更はしない |
| **コミット細分化** | 各段階でコミットして戻れるように |
| **レビュー** | AIの変更内容を必ず確認 |

次のセクションでは、テスト・CI/CD関連の指示について解説します。
